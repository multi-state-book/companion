### Read data and SAS macro

::: {.panel-tabset}
## R
```{r}
#| label: read-pbc3-r
pbc3 <- read.csv("data/pbc3.csv")
pbc3$fail <- as.numeric(with(pbc3, status > 0))
pbc3$log2bili <- with(pbc3, log2(bili))

```

## SAS
```{sas}
#| label: read-pbc3-sas
#| eval: false 
#| output: false
proc import out=pbc3
	datafile="data/pbc3.csv"
	dbms=csv replace;
run;
	
* NB: Inside the macros below a variable called `id` is created which will interfere 
  with your identification variable if it is also called `id` in your data set,
  in which case you will need to rename your `id` variable. We have to do it for pbc3;

data pbc3; 
	set pbc3;
	fail=(status>0); 
	log2bili=log2(bili);
	years=days/365.25;
	rename id=ptno;
run;
```

#### Macro `pseudosurv`

This SAS macro computes pseudo-values based on Kaplan-Meier estimates and is adapted from that described by:

-   J.P.Klein, M.Gerster, P.K.Andersen, S.Tarima, M.Pohar Perme (2008): "SAS and R functions to compute pseudo-values for censored data regression" Comp. Meth. Progr. Biomed., vol. 89,pp. 289-300. */ 

NB: Inside the macros below a variable called `id` is created which will interfere with your identification variable if it is also called `id` in your data set, in which case you will need to rename your `id` variable. We have to do it for pbc3.

```{sas}
#| label: macro-pseudosurv-sas
#| eval: false 
#| output: false

* Can also be found on: 
  https://biostat.ku.dk/pka/epidata/pseudosurv.sas; 

* 'noprint plots = none' are included twice in the proc lifetest statement of the MACRO to avoid none important outputs being printed;

%macro pseudosurv(indata,time,dead,howmany,datatau,outdata);

/* The subsequent SAS code is adapted from that described by J.P.Klein,
    M.Gerster, P.K.Andersen, S.Tarima, M.Pohar Perme (2008): "SAS and R
    functions to compute pseudo-values for censored data regression"
    Comp. Meth. Progr. Biomed., vol. 89,pp. 289-300. */ 

/*    MACRO COMPUTES PSEUDOVALUES BASED ON THE KAPLAN-MEIER ESTIMATOR AT EACH
      TIME
      INPUTS:
      INDATA---INPUT DATA SET
      TIME--TIME VARIABLE
      DEAD---EVENT INDICATOR (1-EVENT, 0-CENSORED)
      HOWMANY---SAMPLE SIZE
      DATATAU---SUBSET OF INPUT DATA SET AT WHICH PSEUDO VALUES ARE COMPUTED DATA
                SET HAS SINGLE VARIABLE TIME
     
      OUTDATA---OUTPUT DATA SET WHICH CONTAINS PSUK,K=1,...,HOWMANY THE PSEUDO
      VALUES AT EACH TIME POINT (Note output data set includes orginal data sorted
                           by time
      
*/
 
proc sort data=&indata;
by &time;

data keep;  set &datatau;
find=1;
proc sort data=keep;  by time;

data point;  set &indata;
time=&time;
keep=1;
 

data point;  merge point keep;  by time;
keep time find keep;
 
data useme;  set point;
retain temp -1;
if keep = 1 then temp=time;
tuse=temp; 
if find ne 1 then delete;
&time=tuse;
 run;
/* WORKING DATA SET THAT INCLUDE A SET OF N INDICATORS WHERE FOR THE KTH INDICATOR
 THE EVENT IS MISSING */
data newdat;  set &indata;
id+1;
array iobs(&howmany) dead1-dead&howmany;
do j=1 to &howmany;
iobs(j)=&dead;
if j=id then iobs(j)=.;
end;

data out;  set newdat;

/* COMPUTE KME FOR FULL SAMPLE */

proc lifetest data=newdat noprint plots = none;
time &TIME*&dead(0);
survival out=sall;
data sall;  set sall;
sall=survival;
 keep &time sall;
 
%do ip=1 %to &howmany;

/* COMPUTE KME FOR REDUCED SAMPLE */
proc lifetest data=newdat noprint plots = none;
time &time*dead&ip(0);
survival out=stmp;
data stmp;  set stmp;
s&ip=survival;
keep &time s&ip;
 
/*merge KMEs AND COMPUTE PSEUDOVALUES FOR OBSERVATION IP*/
data pstmp; merge sall stmp;  by &time;
retain stemp 1;
if s&ip=. then s&ip=stemp;
stemp=s&ip;
psu&ip=&howmany*sall- (&howmany-1)*s&ip;
 
data out; merge out pstmp useme ;  by &time;
if find ne 1 then delete;
keep &time psu1-psu&ip;
%end;

data out;  set out;
retain dup -1;
if &time=dup then delete;
 else dup=&time;
 jd+1;
 
data io;  set out;
array ps psu1-psu&howmany;
do id=1 to &howmany;
pseudo=ps(id);
time=&time;
output;
end;
keep time id pseudo jd;
proc sort data=io ;
  by id;
  
data a;  set &indata;
id+1;
data io;  merge a io;  by id;
 proc sort data=io;  by jd;

proc sort data=&datatau;
by time;

data taus;  set &datatau ;
 jd+1;
 tpseudo=time;
 keep jd tpseudo;
 
 
  data &outdata;  merge io taus;  by jd;
  drop jd id &time &dead;
	run;
%mend;
```

:::

### Figure 6.1

::: {.panel-tabset}
## R
```{r}
#| label: figure-6.1-r
#| out-width: 90%

# General plotting style
library(ggplot2)
theme_general <- theme_bw() +
  theme(legend.position = "bottom", 
        text = element_text(size = 20), 
        axis.text.x = element_text(size = 20), 
        axis.text.y = element_text(size = 20)) 

# Calculate pseudo-observations of the survival function for subjects
# The subjects with id=415 and 458 are selected
# The subjects with id=305 and 325 are selected
library(pseudo)
pseudo_allt <- pseudosurv(pbc3$days, pbc3$fail)

# Re-arrange the data into a long data set
b <- NULL
for(it in 1:length(pseudo_allt$time)){
  b <- rbind(b,cbind(pbc3,
                     pseudo = pseudo_allt$pseudo[,it],
                     tpseudo = pseudo_allt$time[it],
                     id = 1:nrow(pbc3)))
}
b <- b[order(b$id),]
pseudo_alltid <- b

# Subset the two subjects 
subdat <- subset(pseudo_alltid, id %in% c("305", "325"))

# Collect data for plot
pseudodata <- data.frame(tpseudo = subdat$tpseudo / 365.25, 
                         pseudo = subdat$pseudo, 
                         id = as.factor(subdat$id))

fig6.1 <- ggplot(aes(x = tpseudo, y = pseudo, linetype = id), 
                 data = pseudodata) + 
  geom_hline(yintercept = c(0, 1), color = "darkgrey", size = 1) + 
  geom_step(linewidth = 1) + 
  scale_linetype_manual("Patient number", values = c("dashed", "dotted")) + 
  xlab("Time since randomization (years)") + 
  ylab("Pseudo-values") + 
  scale_x_continuous(expand = expansion(mult = c(0.02, 0.05))) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05))) +
  theme_general +
  theme(legend.position = "none")

fig6.1
```

## SAS-NA
```{sas}
#| label: figure-6.1-sas
#| eval: false 
#| output: false
```

:::

### Figure 6.2

::: {.panel-tabset}
## R

#### (a)

```{r}
#| label: figure-6.2a-r
#| out-width: 90%

theme_general_1 <- theme_bw() +
  theme(legend.position = "none", 
        text = element_text(size = 26), 
        axis.text.x = element_text(size = 26), 
        axis.text.y = element_text(size = 26)) 

# Select the pseudo-observations at times 
times <- c(366, 743, 1105)

# At 1 year
pseudo_t1 <- subset(pseudo_alltid, tpseudo == times[1])

# Collect data for plot
pseudodata <- data.frame(tpseudo = pseudo_t1$tpseudo / 365.25, 
                         days = pseudo_t1$days,
                         pseudo = pseudo_t1$pseudo, 
                         failtype = as.factor(pseudo_t1$fail))

fig6.2 <- ggplot(aes(x = days  / 365.25, y = pseudo, shape = failtype), 
                 data = pseudodata) + 
  geom_point(size = 6) + 
  scale_shape_manual("Fail", values = c(4, 1)) + 
  xlab(expression("X"[i]*" (years)")) + 
  ylab("Pseudo-values") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(0, 6, 1)) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     limits = c(-0.9, 1.1)) +
  theme_general_1

fig6.2
```

#### (b)

```{r}
#| label: figure-6.2b-r
#| out-width: 90%

# At 2 years
pseudo_t2 <- subset(pseudo_alltid, tpseudo == times[2])

# Collect data for plot
pseudodata <- data.frame(tpseudo = pseudo_t2$tpseudo / 365.25, 
                         days = pseudo_t2$days,
                         pseudo = pseudo_t2$pseudo, 
                         failtype = as.factor(pseudo_t2$fail))

fig6.2b <- ggplot(aes(x = days / 365.25, y = pseudo, shape = failtype), 
                  data = pseudodata) + 
  geom_point(size = 6) + 
  scale_shape_manual("Fail", values = c(4, 1)) + 
  xlab(expression("X"[i]*" (years)")) +  
  ylab("Pseudo-values") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(0, 6, 1)) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     limits = c(-0.9, 1.1)) +
  theme_general_1

fig6.2b
```

#### (c)

```{r}
#| label: figure-6.2c-r
#| out-width: 90%

# At 3 years
pseudo_t3 <- subset(pseudo_alltid, tpseudo == times[3])

# Collect data for plot
pseudodata <- data.frame(tpseudo = pseudo_t3$tpseudo / 365.25, 
                         days = pseudo_t3$days,
                         pseudo = pseudo_t3$pseudo, 
                         failtype = as.factor(pseudo_t3$fail))

fig6.2c <- ggplot(aes(x = days/365.25, y = pseudo, shape = failtype), 
                  data = pseudodata) + 
  geom_point(size = 6) + 
  scale_shape_manual("Fail", values = c(4, 1)) + 
  xlab(expression("X"[i]*" (years)")) + 
  ylab("Pseudo-values") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(0, 6, 1)) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     limits = c(-0.9, 1.1)) +
  theme_general_1 +
  theme(legend.position="none")

fig6.2c
```

## SAS
```{sas}
#| label: figure-6.2-sas
#| eval: false 
#| output: false
data timepoints;
	input time;
	datalines;
	366
	743
	1105
	;
run;
%pseudosurv(pbc3, days, fail, 349, timepoints, outdata);

data outdata; 
	set outdata;
	fail=(status>0); 
run;

proc gplot data=outdata;
	where time=366;
	plot pseudo*years = fail / haxis=axis1 vaxis=axis2;
	axis1 order=0 to 6 by 1 minor=none label=('Years');
	axis2 order=-0.9 to 1.1 by 0.1 minor=none label=(a=90 'Pseudo-values');
	symbol1  v=x i=none c=black;
	symbol2  v=o i=none c=black;
run;
quit;

proc gplot data=outdata;
	where time=743;
	plot pseudo*years = fail / haxis=axis1 vaxis=axis2;
	axis1 order=0 to 6 by 1 minor=none label=('Years');
	axis2 order=-0.9 to 1.1 by 0.1 minor=none label=(a=90 'Pseudo-values');
	symbol1  v=x i=none c=black;
	symbol2  v=o i=none c=black;
run;
quit;

proc gplot data=outdata;
	where time=1105;
	plot pseudo*years = fail / haxis=axis1 vaxis=axis2;
	axis1 order=0 to 6 by 1 minor=none label=('Years');
	axis2 order=-0.9 to 1.1 by 0.1 minor=none label=(a=90 'Pseudo-values');
	symbol1  v=x i=none c=black;
	symbol2  v=o i=none c=black;
run;
quit;
```

:::


### Figure 6.3

::: {.panel-tabset}
## R

#### Left

```{r}
#| label: figure-6.3left-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

# Collect data for plot year=2
pseudodata <- data.frame(tpseudo = pseudo_t2$tpseudo / 365.25, 
                         days = pseudo_t2$days,
                         pseudo = pseudo_t2$pseudo, 
                         log2bili =  pseudo_t2$log2bili, 
                         bili = pseudo_t2$bili,
                         alb = pseudo_t2$alb,
                         tment = pseudo_t2$tment,
                         id = pseudo_t2$id,
                         failtype = as.factor(pseudo_t2$fail))

bili_loess <- loess(pseudo ~ bili, data = pseudodata, span = 0.8, degree = 1)
pseudodata$loesspred <- predict(bili_loess)

pseudodata$t_loesspred <- with(
  pseudodata, ifelse(loesspred > 0 , log(-log(loesspred)), NA)
  )

fig6.3left <- ggplot(aes(x = bili, y = pseudo), data = pseudodata) + 
  geom_point(size = 4, shape = 4) + 
  geom_line(aes(x = bili, y = loesspred), linewidth = 1) +
  xlab("Bilirubin") +  
  ylab("Pseudo-values") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05))) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(-0.4, 1.2, by = 0.2), 
                     limits = c(-0.4, 1.2)) +
  theme_general

fig6.3left
```

#### Right

```{r}
#| label: figure-6.3right-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

fig6.3right <- ggplot(aes(x = bili, y = t_loesspred), data = pseudodata) + 
  geom_line(size = 1) + 
  xlab("Bilirubin") +  
  ylab("log(-log(predicted pseudo-values))") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05))) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(-5, 2, by = 1), 
                     limits = c(-5, 2)) +
  theme_general

fig6.3right
```



## SAS
```{sas}
#| label: figure-6.3-sas
#| eval: false 
#| output: false
proc sort data=outdata; 
	by bili;
run;

* Left plot; 
proc gplot data=outdata;
	where time=743;
	plot pseudo*bili/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 500 by 50 minor=none label=('Bilirubin');
	axis2 order=-0.4 to 1.2 by 0.2 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=x i=sm70; * i=sm70 specifies that a smooth line is fit to data;
run;
quit;

* Right plot; 
proc loess data=outdata;
	where time=743;
	model pseudo=bili/smooth=0.7;
	output out=smbili p=smooth;
run;
data smbili; 
	set smbili;
	line=log(-log(smooth));
run;
proc sort data=smbili; 
	by bili; 
run;
proc gplot data=smbili;
	plot line*bili/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 500 by 50 minor=none label=('Bilirubin');
	axis2 order=-5 to 2 by 1 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=none i=join;
run;
quit;
```

:::

### Figure 6.4

::: {.panel-tabset}
## R

#### Left

```{r}
#| label: figure-6.4left-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

# Loess for log2 bili
log2bili_loess <- loess(pseudo ~ log2bili, data = pseudodata, span = 0.8, degree = 1)
pseudodata$log2bili_loesspred <- predict(log2bili_loess)

pseudodata$t_log2bili_loesspred <- with(pseudodata,
                               ifelse(log2bili_loesspred > 0 , log(-log(log2bili_loesspred)), NA))

fig6.4left <- ggplot(aes(x = log2bili, y = pseudo), data = pseudodata) +
  geom_point(size = 4, shape = 4) +
  geom_line(aes(x = log2bili, y = log2bili_loesspred), linewidth = 1) +
  xlab(expression("log" [2] * "(bilirubin)")) +
  ylab("Pseudo-values") +
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), limits = c(1, 9),
                     breaks = seq(1, 9, by = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), breaks = seq(-0.4, 1.2, by = 0.2),
                     limits = c(-0.4, 1.2)) +
  theme_general

fig6.4left
```

#### Right
```{r}
#| label: figure-6.4right-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

fig6.4right <- ggplot(aes(x = log2bili, y = t_log2bili_loesspred), data = pseudodata) +
  geom_line(linewidth = 1) +
  xlab(expression("log" [2] * "(bilirubin)")) +
  ylab("log(-log(predicted pseudo-values))") +
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), limits = c(1, 9),
                     breaks = seq(1, 9, by = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), breaks = seq(-5, 2, by = 1),
                     limits = c(-5, 2)) +
  theme_general

fig6.4right
```




## SAS
```{sas}
#| label: figure-6.4-sas
#| eval: false 
#| output: false
* Left plot; 
proc gplot data=outdata;
	where time=743;
	plot pseudo*log2bili/haxis=axis1 vaxis=axis2;
	axis1 order=1 to 9 by 1 minor=none label=('log2(bilirubin)');
	axis2 order=-0.4 to 1.1 by 0.1 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=x i=sm70;* i=sm70 specifies that a smooth line is fit to data;
run;
quit;

* Right plot; 
proc loess data=outdata;
	where time=743;
	model pseudo=log2bili/smooth=0.7;
	output out=smlogbili p=smooth;
run;
data smlogbili; 
	set smlogbili;
	line=log(-log(smooth));
run;
proc sort data=smlogbili; 
	by bili; 
run; 
proc gplot data=smlogbili;
	plot line*log2bili/haxis=axis1 vaxis=axis2;
	axis1 order=1 to 9 by 1 minor=none label=('log2(Bilirubin)');
	axis2 order=-5 to 2 by 1 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=none i=join;
run;
quit;
```

:::

### Table 6.1

Estimates and SD in the book are from SAS `proc genmod`.

::: {.panel-tabset}
## R

In R we have at least three ways to estimate: 

-   When using `geese` from `geepack` package for the three time points model the SDs are smaller compared to SAS
-   Using `svyglm` from `survey` package gives comparable SDs to SAS
-   Package `eventglm` is another option with other issues -- see comments in the R code

#### Function `geese` from `geepack`package

```{r}
#| label: table-6.1-geese-r

library(geepack)

# summary function for pseudo-value regression from a geese fit
summgeese<-function(pofit,d=6){
  beta<-pofit$beta
  SD = sqrt(diag(pofit$vbeta))
  round(cbind(
    beta = beta, 
    SD.robust = SD, 
    exp.beta = exp(beta), 
    exp.lci  = exp(beta-1.96*SD), 
    exp.uci  = exp(beta+1.96*SD), 
    PVal.N = 2-2*pnorm(abs(beta/SD))),d) 
}

# At day 743
# data frame pseudodata countains pseudo-observations day 743
geefit1 <- geese(formula = I(1 - pseudo) ~ tment +alb + log2bili,
              data = subset(pseudodata, !is.na(alb)),
              id = id,
              mean.link = "cloglog")
summgeese(geefit1)

# At days 366, 743, 1105 
# Select the pseudo-observations at times
times <- c(366, 743, 1105)
pseudo_t1 <- subset(pseudo_alltid, tpseudo == times[1])
pseudo_t2 <- subset(pseudo_alltid, tpseudo == times[2])
pseudo_t3 <- subset(pseudo_alltid, tpseudo == times[3])
pseudo_t <- rbind(pseudo_t1, pseudo_t2, pseudo_t3)
pseudodata_t <- data.frame(tpseudo = pseudo_t$tpseudo,
                         days = pseudo_t$days,
                         pseudo = pseudo_t$pseudo,
                         log2bili =  pseudo_t$log2bili,
                         bili = pseudo_t$bili,
                         alb = pseudo_t$alb,
                         tment = pseudo_t$tment,
                         id = pseudo_t$id,
                         failtype = as.factor(pseudo_t$fail))
geefit3 <- geese(formula = I(1 - pseudo) ~ tment +alb + log2bili + factor(tpseudo)-1,
              data = subset(pseudodata_t, !is.na(alb)),
              id = id,
              mean.link = "cloglog")
summgeese(geefit3) 
```


#### Function `svyglm` from `survey` package

```{r}
#| label: table-6.1-survey-r

library(survey)
library(survival) # get bcloglog()

# Thanks to Terry Therneau for this comment:
# It needs one more line to set up compaed to geese, but has 3 advantages: 
# 1: naturally deals with missing values in the data
# 2: results follow standard R nomenclature, e.g., the coef and vcov functions work as expected
# 3: geese gives incorrect answers, without warning, if the data set is not sorted in exactly the order it expects
# Also: The bounded cloglog link, bcloglog(), avoid an error message in glm's initial values step. It's found in the survival package.


# summary function for pseudo-value regression from a svyglm fit
summsvy<-function(pofit,d=5){
  beta<-pofit$coefficient
  SD<-sqrt(diag(pofit$cov.unscaled))
  round(cbind(
    beta = beta, 
    SD.robust = SD,
    exp.beta = exp(beta), 
    exp.lci = exp(beta-1.96*SD), 
    exp.uci = exp(beta+1.96*SD), 
    PVal.N = 2-2*pnorm(abs(beta/SD))),d)
}

# At days 743
svydata <- svydesign(~id, variables= ~., data=pseudodata, weight= ~1)
svyfit1 <- svyglm(I(1 - pseudo) ~ tment + alb + log2bili,
               design=svydata, family= gaussian(link= bcloglog()))
summsvy(svyfit1)

# At days 366, 743, 1105 
svydata3 <- svydesign(~id, variables= ~., data=pseudodata_t, weight= ~1)
svyfit3 <- svyglm(I(1 - pseudo) ~ tment + alb + log2bili+factor(tpseudo)-1,
                 design=svydata3, family= gaussian(link= bcloglog()))
summsvy(svyfit3)
```

#### Function `cumincglm` from `eventglm`package

Now, using `eventglm` package. Handling of missing values (here for variable `alb`) causes some issue, see comment in R code below.

```{r}
#| label: table-6.1-eventglm-r

library(eventglm)
# At day 743
# SD differ a bit from from than SAS, geese, and svyglm
egfit1 <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = 743,
                    data = pbc3, link="cloglog")
summary(egfit1)

# Use of argument subset gives the same
egfit1x <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = 743,
                    data = pbc3, subset=!is.na(alb), link="cloglog")
summary(egfit1x)

# Sub-setting the data is not the way:
# When sub-setting, the pseudo-values are calculated base on the sub-sample,
# which is different from all the above where the full sample is used to
# calculate the pseudo-values
egfit1xx <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = 743,
                    data = subset(pbc3,!is.na(alb)), link="cloglog")
summary(egfit1xx)

# At days 366, 743, 1105 
# For multiple time points we get an error for this code:
# egfit3 <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = c(366, 743, 1105),
#                    data = pbc3, link="cloglog")
# Error in model.frame.default(formula = formula2i, data = newdatasrt, weights = weights,  : 
# variable lengths differ (found for '(weights)')
# Try to use argument subset, but get same error
# egfit3x <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = c(366, 743, 1105),
#                    data = pbc3, subset=!is.na(alb), link="cloglog")

# Have to do sub-setting on data, but this is not the way to do it
# but is in this case VERY close to svyglm results
egfit3xx <- cumincglm(Surv(days, fail) ~ tment + alb + log2bili, time = c(366, 743, 1105),
                    data = subset(pbc3,!is.na(alb)), link="cloglog")
summary(egfit3xx)
```


## SAS

```{sas}
#| label: table-6.1-sas
#| eval: false 
#| output: false

# Rename the id variable ;
data pbc3; 
	set pbc3; 
	rename id=ptno;
run; 
proc sort data=pbc3; 
	by days; 
run;

data timepoints;
	input time;
	datalines;
	366
	743
	1105
	;
run;

%pseudosurv(pbc3, days, fail, 349, timepoints, outdata);

* At day 743 ----------------------------------------------------------------;
proc genmod data=outdata;
	where time=743;
	class ptno;
	fwdlink link=log(-log(_mean_));
	invlink ilink=exp(-exp(_xbeta_));
	model pseudo=tment alb log2bili / dist=normal noscale;
	repeated subject=ptno/corr=ind;
run;

              Analysis Of GEE Parameter Estimates
               Empirical Standard Error Estimates

                    Standard   95% Confidence
 Parameter Estimate    Error       Limits            Z Pr > |Z|

 Intercept  -2.1167   1.3270  -4.7175   0.4842   -1.60   0.1107
 tment      -0.7051   0.3693  -1.4289   0.0188   -1.91   0.0563
 alb        -0.1051   0.0342  -0.1720  -0.0381   -3.08   0.0021
 log2bili    0.8357   0.1404   0.5605   1.1110    5.95   <.0001

* At days 366 , 743, 1105 ----------------------------------------------------;
proc genmod data=outdata;
	class ptno time;
	fwdlink link=log(-log(_mean_));
	invlink ilink=exp(-exp(_xbeta_));
	model pseudo=tment alb log2bili time / dist=normal noscale noint;
	repeated subject=ptno/corr=ind;
run;

                 Analysis Of GEE Parameter Estimates
                 Empirical Standard Error Estimates

                         Standard   95% Confidence
 Parameter      Estimate    Error       Limits            Z Pr > |Z|

 Intercept        0.0000   0.0000   0.0000   0.0000     .      .
 tment           -0.5985   0.2870  -1.1610  -0.0361   -2.09   0.0370
 alb             -0.0939   0.0263  -0.1454  -0.0424   -3.58   0.0003
 log2bili         0.6841   0.0919   0.5040   0.8642    7.44   <.0001
 time      366   -2.4746   1.1423  -4.7135  -0.2357   -2.17   0.0303
 time      743   -1.5540   1.1211  -3.7514   0.6434   -1.39   0.1657
 time      1105  -1.1232   1.1256  -3.3293   1.0829   -1.00   0.3183
```

:::

### Figure 6.5

::: {.panel-tabset}
## R
```{r}
#| label: figure-6.5-r
#| out-width: 90%

# At time year c(1, 2, 3) 
fit2 <- geese(formula = I(1 - pseudo) ~ as.factor(tpseudo) + log2bili + alb + tment - 1, 
              data = subset(pseudodata_t, !is.na(alb)), 
              id = id, 
              mean.link = "cloglog",
              variance = "gaussian",
              scale.value = 0, 
              scale.fix = 1)
pseudodata_t$pred <- rep(NA, nrow(pseudodata_t))

# At time 1
pseudodata_t[pseudodata_t$tpseudo == times[1] / 365.25,]$pred <- 
  with(pseudodata_t[pseudodata_t$tpseudo == times[1] / 365.25,],
        fit2$beta[1] + fit2$beta[4]*log2bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# At time 2
pseudodata_t[pseudodata_t$tpseudo == times[2] / 365.25,]$pred <- 
  with(pseudodata_t[pseudodata_t$tpseudo == times[2] / 365.25,],
       fit2$beta[2] + fit2$beta[4]*log2bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# At time 3
pseudodata_t[pseudodata_t$tpseudo == times[3] / 365.25,]$pred <- 
  with(pseudodata_t[pseudodata_t$tpseudo == times[3] / 365.25,],
       fit2$beta[3] + fit2$beta[4]*log2bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# Transform back
pseudodata_t$res <- with(pseudodata_t, pseudo - exp(-exp(pred)))
pseudodata_t$time <- as.factor(pseudodata_t$tpseudo * 365.25)

# Make loess smooth per time
log2bili_res_loess_1 <- loess(res ~ log2bili, 
                              data = subset(pseudodata_t, time == 366), span = 0.7, degree = 1)
log2bili_res_loess_2 <- loess(res ~ log2bili, 
                              data = subset(pseudodata_t, time == 743), span = 0.7, degree = 1)
log2bili_res_loess_3 <- loess(res ~ log2bili, 
                              data = subset(pseudodata_t, time == 1105), span = 0.7, degree = 1)

log2bili_res_pred_1 <- predict(log2bili_res_loess_1, newdata = subset(pseudodata_t, time == 366))
log2bili_res_pred_2 <- predict(log2bili_res_loess_2, newdata = subset(pseudodata_t, time == 743))
log2bili_res_pred_3 <- predict(log2bili_res_loess_3, newdata = subset(pseudodata_t, time == 1105))

pseudodata_t$log2bili_res_pred <- c(log2bili_res_pred_1, log2bili_res_pred_2, log2bili_res_pred_3)

fig6.5 <- ggplot(aes(x = log2bili, y = res, shape = time), data = pseudodata_t) + 
  geom_line(aes(x = log2bili, y = log2bili_res_pred , linetype = time), linewidth = 1) +
  geom_point(size = 3) + 
  scale_shape_manual("Year", values = c(4, 2, 0), labels = c("1", "2", "3")) +
  scale_linetype_manual("Year", values = c("dashed", "solid", "dotted"), labels = c("1", "2", "3")) +
  xlab(expression("log" [2] * "(bilirubin)")) +  
  ylab("Pseudo-residuals") + 
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), limits = c(1, 9), 
                     breaks = seq(1, 9, by = 1)) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), breaks = seq(-2, 1, by = 1), 
                     limits = c(-2, 1)) +
  theme_general + 
  theme(legend.box = "vertical",
        text = element_text(size=20), 
        legend.key.size = unit(1.5, 'cm'),
        legend.text = element_text(size = 20))


fig6.5

```



## SAS
```{sas}
#| label: figure-6.5-sas
#| eval: false 
#| output: false

data fig6_5; set outdata;
	if time=366 then do;
	linpred=-2.4746+0.6841*log2bili-0.0939*alb-0.5985*tment;
	pred=exp(-exp(linpred)); res=pseudo-pred; end;
	if time=743 then do;
	linpred=-1.5540+0.6841*log2bili-0.0939*alb-0.5985*tment;
	pred=exp(-exp(linpred)); res=pseudo-pred; end;
	if time=1105 then do;
	linpred=-1.1232+0.6841*log2bili-0.0939*alb-0.5985*tment;
	pred=exp(-exp(linpred)); res=pseudo-pred; end;
run;

proc gplot data=fig6_5;
	plot res*log2bili=time/haxis=axis1 vaxis=axis2;
	axis1 order=1 to 9 by 1 minor=none label=('log2(Bilirubin)');
	axis2 order=-2 to 1 by 1 minor=none label=(a=90 'Pseudo-residuals');;
	symbol1 v=x i=sm50;
	symbol2 v=o i=sm50;
	symbol3 v=+ i=sm50;
run;
quit;
```

:::

### Table 6.2

::: {.panel-tabset}
## R
```{r}
#| label: table-6.2-r

# At days 366 , 743, 1105 using link function "-log"
# No default link function "-log" R, thus add "-" in front of all beta estimates
summsvy(svyglm(pseudo ~ tment + alb + bili + factor(tpseudo)-1 , 
                design=svydata3, family=gaussian(link=blog())))
```


## SAS
```{sas}
#| label: table-6.2-sas
#| eval: false 
#| output: false
#| 
*  At days 366 , 743, 1105 using link function "-log"; 
proc genmod data=outdata;
	class ptno time;
	fwdlink link=-log(_mean_);
	invlink ilink=exp(-_xbeta_);
	model pseudo=tment alb bili time  /dist=normal noscale noint;
	repeated subject=ptno / corr=ind;
run;

                Analysis Of GEE Parameter Estimates
                Empirical Standard Error Estimates

                          Standard   95% Confidence
  Parameter      Estimate    Error       Limits            Z Pr > |Z|

  Intercept        0.0000   0.0000   0.0000   0.0000     .      .
  tment           -0.0484   0.0311  -0.1093   0.0125   -1.56   0.1194
  alb             -0.0097   0.0032  -0.0159  -0.0034   -3.04   0.0024
  bili             0.0042   0.0008   0.0026   0.0057    5.29   <.0001
  time      366    0.3403   0.1422   0.0616   0.6189    2.39   0.0167
  time      743    0.4120   0.1450   0.1278   0.6963    2.84   0.0045
  time      1105   0.5075   0.1468   0.2199   0.7952    3.46   0.0005
```

:::

### Figure 6.6

::: {.panel-tabset}
## R

#### Left

```{r}
#| label: figure-6.6left-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

# Create Figure 6.6 (a) - done earlier
fig6.6left <- fig6.3left
fig6.6left
```

#### Right

```{r}
#| label: figure-6.6right-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

# Same as earlier:
bili_loess <- loess(pseudo ~ bili, data = pseudodata, span = 0.8, degree = 1)
pseudodata$loesspred <- predict(bili_loess)

# Use log-trans instead of cloglog
pseudodata$log_loesspred <- with(pseudodata,
                               ifelse(loesspred > 0 , -log(loesspred), NA))

fig6.6right <- ggplot(aes(x = bili, y = log_loesspred), data = pseudodata) +
  geom_line(linewidth = 1) +
  xlab("Bilirubin") +
  ylab("-log(predicted pseudo-values)") +
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05))) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), breaks = seq(-1, 3, by = 1),
                     limits = c(-1, 3)) +
  theme_general

fig6.6right
```


## SAS
```{sas}
#| label: figure-6.6-sas
#| eval: false 
#| output: false
* Right plot; 
proc sort data=outdata; 
	by bili; 
run;
proc gplot data=outdata;
	where time=743;
	plot pseudo*bili/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 500 by 50 minor=none label=('Bilirubin');
	axis2 order=-0.4 to 1.2 by 0.2 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=x i=sm70;
run;
quit;

* Left plot; 
proc loess data=outdata;
	where time=743;
	model pseudo=bili/smooth=0.7;
	output out=smbili p=smooth;
run;
data smbili; 
	set smbili;
	line=-log(smooth);
run;
proc sort data=smbili; 
	by bili; 
run;
proc gplot data=smbili;
	plot line*bili/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 500 by 50 minor=none label=('Bilirubin');
	axis2 order=-1 to 3 by 1 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=none i=join;
run;
quit;
```

:::

### Figure 6.7

::: {.panel-tabset}
## R
```{r}
#| label: figure-6.7-r
#| out-width: 90%

# Use regression estimates from fit2

pseudodata_t$pred <- rep(NA, nrow(pseudodata_t))

# At time 1
pseudodata_t[pseudodata_t$tpseudo == times[1] / 365.25,]$pred <-
  with(pseudodata_t[pseudodata_t$tpseudo == times[1] / 365.25,],
       fit2$beta[1] + fit2$beta[4]*bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# At time 2
pseudodata_t[pseudodata_t$tpseudo == times[2] / 365.25,]$pred <-
  with(pseudodata_t[pseudodata_t$tpseudo == times[2] / 365.25,],
       fit2$beta[2] + fit2$beta[4]*bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# At time 3
pseudodata_t[pseudodata_t$tpseudo == times[3] / 365.25,]$pred <-
  with(pseudodata_t[pseudodata_t$tpseudo == times[3] / 365.25,],
       fit2$beta[3] + fit2$beta[4]*bili + fit2$beta[5]*alb + fit2$beta[6]*tment)

# Transform back
pseudodata_t$res <- with(pseudodata_t, pseudo - exp(pred))
pseudodata_t$time <- as.factor(pseudodata_t$tpseudo * 365.25)

# Make loess smooth per time
bili_res_loess_1 <- loess(res ~ bili,
                          data = subset(pseudodata_t, time == 366), 
                          span = 0.7, degree = 1)
bili_res_loess_2 <- loess(res ~ bili,
                          data = subset(pseudodata_t, time == 743), 
                          span = 0.7, degree = 1)
bili_res_loess_3 <- loess(res ~ bili,
                          data = subset(pseudodata_t, time == 1105), 
                          span = 0.7, degree = 1)

bili_res_pred_1 <- predict(bili_res_loess_1, 
                           newdata = subset(pseudodata_t, time == 366))
bili_res_pred_2 <- predict(bili_res_loess_2, 
                           newdata = subset(pseudodata_t, time == 743))
bili_res_pred_3 <- predict(bili_res_loess_3, 
                           newdata = subset(pseudodata_t, time == 1105))

pseudodata_t$bili_res_pred <- c(bili_res_pred_1, 
                                bili_res_pred_2, 
                                bili_res_pred_3)

# Create Figure
fig6.7 <- ggplot(aes(x = bili, y = res, shape = time), data = pseudodata_t) +
  geom_line(aes(x = bili, y = bili_res_pred , linetype = time), linewidth = 1) +
  geom_point(size = 3) +
  scale_shape_manual("Year", values = c(4, 2, 0), 
                     labels = c("1", "2", "3")) +
  scale_linetype_manual("Year", 
                        values = c("dashed", "solid", "dotted"), 
                        labels = c("1", "2", "3")) +
  xlab(expression("Bilirubin")) +
  ylab("Pseudo-residuals") +
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     limits = c(0, 500),
                     breaks = seq(0, 500, by = 100)) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), 
                     breaks = seq(-2, 1, by = 1),
                     limits = c(-2, 1)) +
  theme_general +
  theme(legend.box = "vertical",
        text = element_text(size=20),
        legend.key.size = unit(2, 'cm'),
        legend.text = element_text(size = 20))

fig6.7
```



## SAS
```{sas}
#| label: figure-6.7-sas
#| eval: false 
#| output: false
data fig6_7; 
	set outdata;
	if time=366 then do;
	linpred2=0.3403+0.0042*bili-0.0097*alb-0.0484*tment;
	pred2=exp(-linpred2); res2=pseudo-pred2; end;
	if time=743 then do;
	linpred2=0.4120+0.0042*bili-0.0097*alb-0.0484*tment;
	pred2=exp(-linpred2); res2=pseudo-pred2; end;
	if time=1105 then do;
	linpred2=0.5075+0.0042*bili-0.0097*alb-0.0484*tment;
	pred2=exp(-linpred2); res2=pseudo-pred2; end;
run;

proc gplot data=fig6_7;
	plot res2*bili=time/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 500 by 100 minor=none label=('Bilirubin');
	axis2 order=-2 to 1 by 1 minor=none label=(a=90 'Pseudo-residuals');;
	symbol1 v=x i=sm50;
	symbol2 v=o i=sm50;
	symbol3 v=+ i=sm50;
run;
quit;
```

:::

### Table 6.3

::: {.panel-tabset}
## R

Here, `geese`, `svyglm`, and `rmeanglm` (from package `eventglm`) give very similar results.

```{r}
#| label: table-6.3-r

# Calculate pseudo-observations of the restricted mean and merge with pbc3
datarmean3<-cbind(pbc3,pseudormean=pseudomean(pbc3$days/365.25,pbc3$fail,tmax = 3))

# geese
summgeese(geese(pseudormean ~ tment + alb + log2bili, id = id,
                data = subset(datarmean3, !is.na(alb)),
                family = "gaussian", mean.link = "identity",
                corstr = "independence"))
# svyglm
svydata <- svydesign(~id, variables= ~., data=datarmean3, weight= ~1)
summsvy(svyglm(pseudormean ~ tment + alb + log2bili, design=svydata,
               family= gaussian(link="identity")))

# rmeanglm from package eventglm
summary(rmeanglm(Surv(days/365.25, fail) ~ tment + alb + log2bili,time = 3,
                 data = pbc3, link="identity"))
```

## SAS

#### `proc rmstreg`

```{sas}
#| label: rmstreg-sas
#| eval: false 
#| output: false
proc rmstreg data=pbc3 tau=3;
   model years*status(0)=tment alb log2bili / link=linear;
run;
                            Analysis of Parameter Estimates

                               Standard       95% Confidence          Chi-
Parameter    DF    Estimate       Error           Limits            Square    Pr > ChiSq

Intercept     1      2.8263      0.3467      2.1469      3.5058      66.47        <.0001
tment         1      0.1480      0.0730      0.0048      0.2911       4.11        0.0427
alb           1      0.0225      0.0068      0.0092      0.0359      10.92        0.0010
log2bili      1     -0.2435      0.0320     -0.3063     -0.1808      57.83        <.0001
```


#### Macro `pseudomean`

SAS macro for computing pseudo-values of the restricted mean based on Kaplan-Meier estimates.

NB: Inside the macro a variable called `id` is created which will interfere with your identification variable is called `id` in your data set, in which case you will need to rename your `id` variable. 

```{sas}
#| label: macro-pseudomean-sas
#| eval: false 
#| output: false

* Can also be found on: 
  https://biostat.ku.dk/pka/epidata/pseudomean.sas; 

%macro pseudomean(indata,time,dead,howmany,tmax,outdata);
 /* MACRO ARGUMENTS
      INDATA--NAME OF INPUT DATA SET
      TIME--NAME OF TIME VARIABLE
      DEAD--NAME OF EVENT INDICATOR VARIABLE--(1-DEAD,0-CENSORED)
      HOWMANY--SAMPLE SIZE
      TMAX--UPPER LIMIT OF INTEGRATION FOR RESTRICTED MEAN
      OUTDATA--NAME OF OUTPUT DATA SET WITH PSEUDOVALUES FPR RESTRICTED
               MEAN IN VARIABLE "PSUMEAN"  */
 
 /* CREATE A DATA SET WHERE EVERYTHING ABOVE TMAX IS CENSORED */
 DATA work; SET &indata;
  restime = MIN(&tmax, &time);
  resdead = &dead;
  IF restime EQ &tmax THEN resdead = 0;

/* CREATE DATA SET WITH SET OF INDICATORS DEADK THAT HAS MISSING VALUE
     FOR KTH OBSERVATION, K=1,...,HOWMANY*/
 DATA work;  SET work;
   id+1;
   ARRAY iobs(&howmany) dead1-dead&howmany;
   DO j = 1 TO &howmany;
    iobs(j) = resdead;
    IF j = id THEN iobs(j) = .;
   END;
 
 /* COMPUTE RESTRICTED MEAN FOR COMPLETE SAMPLE USING PROC LIFETEST */
 
 PROC LIFETEST DATA = work OUTSURV = km ;
   TIME restime*resdead(0);
   ODS SELECT MEANS;
   ODS OUTPUT MEANS = mall;
 RUN;

  DATA km; SET km;
    IF _CENSOR_ EQ 0;
  PROC SORT DATA=km;
    BY restime;
  RUN; 
  DATA km; SET km END=LAST;
    IF NOT(LAST) THEN DELETE;
    area = (&tmax - restime)*survival;
    KEEP area;

  DATA psu; MERGE km mall;
    meanall = mean + area;
    KEEP meanall;
    
 %DO ip = 1 %TO &howmany;
 
   /* COMPUTE RESTRICTED MEAN FOR SAMPLE WITH IPTH OBSERVATION DELETED
      USING PROC LIFETEST */
 
   PROC LIFETEST DATA = work OUTSURV = km1 ;
     TIME restime*dead&ip(0);
     ODS SELECT means;
     ODS OUTPUT MEANS = m1;
   RUN;

   DATA km1; SET km1;
     IF _CENSOR_ EQ 0;
   PROC SORT DATA = km1;
     BY restime;
   RUN;
   DATA km1; SET km1 END=LAST;
     IF NOT(LAST) THEN DELETE;
     area = (&tmax - restime)*survival;
     KEEP area;
   DATA km1; MERGE km1 m1;
     mean = mean + area;
     KEEP mean;

   /* COMPUTE PSEUDOVALUE FOR IPTH OBSERVATION*/
   DATA psu; MERGE psu km1;
     psu&ip=&howmany*meanall-(&howmany-1)*mean;
 %END;
 
 /* TRANSPOSE DATASET AND MERGE WITH RAW DATA*/
 DATA out;  SET psu;
   ARRAY y(&howmany) psu1-psu&howmany;
   DO j = 1 TO &howmany;
     psumean=y(j);
     OUTPUT;
   END;
 KEEP psumean;
 
 DATA &outdata; MERGE &indata out;
 run; 
%MEND;
```

#### Table

```{sas}
#| label: table-6.3-sas
#| eval: false 
#| output: false
%pseudomean(pbc3,years,fail,349,3,outmean3);

proc genmod data=outmean3;
	class ptno;
	model psumean = tment alb log2bili /dist=normal;
	repeated subject=ptno / corr=ind;
run;

              Analysis Of GEE Parameter Estimates
               Empirical Standard Error Estimates

                    Standard   95% Confidence
 Parameter Estimate    Error       Limits            Z Pr > |Z|

 Intercept   2.8256   0.3461   2.1472   3.5040    8.16   <.0001
 tment       0.1478   0.0729   0.0049   0.2908    2.03   0.0427
 alb         0.0225   0.0068   0.0092   0.0359    3.31   0.0009
 log2bili   -0.2431   0.0320  -0.3058  -0.1804   -7.60   <.0001
```

:::

### Figure 6.8

::: {.panel-tabset}
## R
```{r}
#| label: figure-6.8-r
#| out-width: 90%

# Collect data for plot
pseudodata <- data.frame(days = outmean3$days,
                         pseudo = outmean3$pseudo,
                         failtype = as.factor(outmean3$fail))

fig6.8 <- ggplot(aes(x = days / 365.25, y = pseudo, shape = failtype), data = pseudodata) +
  geom_point(size = 6) +
  scale_shape_manual("Fail", values = c(4, 1)) +
  xlab(expression("X"[i]*" (years)")) +
  ylab("Pseudo-values") +
  scale_x_continuous(expand = expansion(mult = c(0.05, 0.05)), limits = c(0, 6),
                     breaks = seq(0, 6, by = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)), limits = c(0, 4)) +
  theme_general +
  theme(legend.position="none")

fig6.8
```


## SAS
```{sas}
#| label: figure-6.8-sas
#| eval: false 
#| output: false

* see %pseudomean(pbc3,years,fail,349,3,outmean3) above for table 6.3;

proc sort data=outmean3; 
	by years; 
run;
proc gplot data=outmean3;
	plot psumean*years=fail/haxis=axis1 vaxis=axis2;
	axis1 order=0 to 6 by 1 minor=none label=('Years');
	axis2 order=0 to 4 by 1 minor=none label=(a=90 'Pseudo-values');
	symbol1  v=x i=none c=black;
	symbol2  v=o i=none c=black;
run;
quit;
```

:::

### Figure 6.9

::: {.panel-tabset}
## R
```{r}
#| label: figure-6.9-r
#| out-width: 90%

# Loess for log2 bili
log2bili_loess <- loess(pseudo ~ log2bili, data = outmean3, span = 0.8, degree = 1)
outmean3$log2bili_loesspred <- predict(log2bili_loess)

#outmean3$t_log2bili_loesspred <- with(outmean3,
#                                        ifelse(log2bili_loesspred > 0 ,
#                                               log(log2bili_loesspred/(1-log2bili_loesspred)), NA))

fig6.9 <- ggplot(aes(x = log2bili, y = pseudo), data = outmean3) +
  geom_point(size = 6, shape = 4) +
  geom_line(aes(x = log2bili, y = log2bili_loesspred), linewidth = 1) +
  xlab(expression("log" [2] * "(bilirubin)")) +
  ylab("Pseudo-values") +
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.05)), limits = c(1, 9),
                     breaks = seq(1, 9, by = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.05)), breaks = seq(0, 4, by = 1),
                     limits = c(0, 4)) +
  theme_general

fig6.9
```

<!-- ### Table 6.4 -->

<!-- ```{r} -->
<!-- #| label: table-6.4 -->

<!-- # Pseudo-obs -->
<!-- pseudo2 <- pseudoci(time = pbc3$days / 365.25, -->
<!--                     event = pbc3$status, -->
<!--                     tmax = 2) -->

<!-- b2 <- NULL -->
<!-- for(it in 1:length(pseudo2$time)){ -->
<!--   b2 <- rbind(b2,cbind(pbc3,pseudo = pseudo2$pseudo[[2]][,it], -->
<!--                        tpseudo = pseudo2$time[it])) -->
<!-- } -->
<!-- b2 <- b2[order(b2$id),] -->

<!-- # GEE fits -->
<!-- fit2 <- geese(pseudo ~ tment + I(alb-40) + I(log2(bili) - 4.6), data = b2, -->
<!--               id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--               mean.link = "logit", corstr = "independence") -->
<!-- summary(fit2) -->


<!-- fit2cloglog <- geese(pseudo ~ tment + I(alb-40) + I(log2(bili) - 4.6), data = b2, -->
<!--                      id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--                      mean.link = "cloglog", corstr = "independence") -->
<!-- summary(fit2cloglog) -->

<!-- # NU ALLE ptt (kun TMENT): -->
<!-- pseudo2tot <- pseudoci(time = pbc3$days / 365.25, -->
<!--                        event = pbc3$status, -->
<!--                        tmax = 2) -->

<!-- b2tot <- NULL -->
<!-- for(it in 1:length(pseudo2tot$time)){ -->
<!--   b2tot <- rbind(b2tot,cbind(pbc3,pseudo = pseudo2tot$pseudo[[2]][,it], -->
<!--                              tpseudo = pseudo2tot$time[it],id=1:nrow(pbc3))) -->
<!-- } -->
<!-- b2tot <- b2tot[order(b2tot$id),] -->


<!-- fit2tment <- geese(pseudo ~ tment, data = b2tot, -->
<!--                    id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--                    mean.link = "logit", corstr = "independence") -->
<!-- summary(fit2tment) -->

<!-- fit2tmentcloglog <- geese(pseudo ~ tment, data = b2tot, -->
<!--                           id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--                           mean.link = "cloglog", corstr = "independence") -->
<!-- summary(fit2tmentcloglog) -->

<!-- ``` -->

<!-- ### Table 6.5 -->

<!-- ```{r} -->
<!-- #| label: table-6.4 -->


<!-- pseudo123 <- pseudoci(time = pbc3$days / 365.25, -->
<!--                       event = pbc3$status, -->
<!--                       tmax = c(1,2,3)) -->

<!-- b123 <- NULL -->
<!-- for(it in 1:length(pseudo123$time)){ -->
<!--   b123 <- rbind(b123,cbind(pbc3,pseudo = pseudo123$pseudo[[2]][,it], -->
<!--                            tpseudo = pseudo123$time[it])) -->
<!-- } -->
<!-- b123 <- b123[order(b123$id),] -->

<!-- # fit123 <- geese(pseudo ~ as.factor(tpseudo) + tment + I(alb-40) + I(log2(bili) - 4.6), -->
<!-- #                 data = b123, -->
<!-- #                 id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!-- #                 mean.link = "cloglog", corstr = "independence") -->
<!-- # summary(fit123) -->

<!-- b123$sex <- relevel(as.factor(b123$sex), ref = "1") -->

<!-- fit123ny <- geese(pseudo ~ as.factor(tpseudo) + tment + I(alb-40) + I(log2(bili) - 4.6) -->
<!--                   + as.factor(sex) + age, data = b123, -->
<!--                   id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--                   mean.link =  "cloglog", corstr = "independence") -->
<!-- summary(fit123ny) -->

<!-- pseudo10 <- pseudoci(time = pbc3$days / 365.25, -->
<!--                      event = pbc3$status, -->
<!--                      tmax = c(0.5,1,1.5,2,2.5,3,3.5,4,4.5,5)) -->

<!-- b10 <- NULL -->
<!-- for(it in 1:length(pseudo10$time)){ -->
<!--   b10 <- rbind(b10,cbind(pbc3,pseudo = pseudo10$pseudo[[2]][,it], -->
<!--                          tpseudo = pseudo10$time[it],id=1:nrow(pbc3))) -->
<!-- } -->
<!-- b10 <- b10[order(b10$id),] -->
<!-- b10$sex <- relevel(as.factor(b10$sex), ref = "1") -->

<!-- fit10 <- geese(pseudo ~ as.factor(tpseudo) + tment + I(alb-40) + I(log2(bili) - 4.6) -->
<!--                + as.factor(sex) + age, data = b10, -->
<!--                id = id, jack = TRUE, scale.fix = TRUE, family = gaussian, -->
<!--                mean.link = "cloglog", corstr = "independence") -->
<!-- summary(fit10) -->
<!-- ``` -->


## SAS
```{sas}
#| label: figure-6.9-sas
#| eval: false 
#| output: false
proc sort data=outmean3; 
	by bili; 
run;
proc gplot data=outmean3;
	plot psumean*log2bili/haxis=axis1 vaxis=axis2;
	axis1 order=1 to 9 by 1 minor=none label=('log2(bilirubin)');
	axis2 order=0 to 4 by 1 minor=none label=(a=90 'Pseudo-values');
	symbol1 v=x i=sm70;
run;
quit;
```

:::

### Table 6.4

::: {.panel-tabset}

## R
```{r}
#| label: table-6.4-r

# Calculate pseudo-values based on Aalen-Johansen estimates using pseudoci()
# and merge with pbc3 data
ci2 <- pseudoci(pbc3$days/365.25, pbc3$status,tmax = 2)
dataci2 <- cbind(pbc3,
               pseudo.trans = as.vector(ci2$pseudo[[1]]),
               pseudo.death = as.vector(ci2$pseudo[[2]]))

# Fit models
geese_logit <- geese(pseudo.death ~ tment , id = id,
                     data = dataci2,
                     family = "gaussian", mean.link = "logit",
                     corstr = "independence", scale.fix = FALSE)
summgeese(geese_logit)
geese_cloglog <- geese(pseudo.death ~ tment, id = id,
                     data = dataci2,
                     family = "gaussian", mean.link = "cloglog",
                     corstr = "independence", scale.fix = FALSE)
summgeese(geese_cloglog)

geese_logit <- geese(pseudo.death ~ tment + alb + log2bili, id = id,
                     data = subset(dataci2, !is.na(alb)),
                     family = "gaussian", mean.link = "logit",
                     corstr = "independence", scale.fix = FALSE)
summgeese(geese_logit)
geese_cloglog <- geese(pseudo.death ~ tment + alb + log2bili, id = id,
                     data = subset(dataci2, !is.na(alb)),
                     family = "gaussian", mean.link = "cloglog",
                     corstr = "independence", scale.fix = FALSE)
summgeese(geese_cloglog)

svydata <- svydesign(~id, variables= ~., data=dataci2, weight= ~1)

svyfit_logit <- svyglm(pseudo.death ~ tment,
                design=svydata, family= gaussian(link=blogit()))
summsvy(svyfit_logit)

svyfit_cloglog <- svyglm(pseudo.death ~ tment,
                design=svydata, family= gaussian(link=bcloglog()))
summsvy(svyfit_cloglog)


svyfit_logit <- svyglm(pseudo.death ~ tment + alb + log2bili,
                design=svydata, family= gaussian(link=blogit()))
summsvy(svyfit_logit)

svyfit_cloglog <- svyglm(pseudo.death ~ tment + alb + log2bili,
                design=svydata, family= gaussian(link=bcloglog()))
summsvy(svyfit_cloglog)

```

## SAS

#### Macros `pseudoci`

To use the macro `pseudoci` we need the following John Klein's `cuminc` macro:

```{sas}
#| label: macro-pseudoci-cuminc-sas
#| eval: false 
#| output: false
%macro cuminc(datain,x,re,de,dataout,cir,cid);
/*  THIS MACRO COMPUTES THE CUMULATIVE INCIDENCE FUNCTIONS FOR
    BOTH COMPETING RISKS USING PROC PHREG OUTPUT
    INPUTS TO MACRO
    DATAIN--NAME OF INPUT DATA SET CONTAINING 
    	X--TIME TO EVENT
    	RE--INDICATOR OF FIRST COMPETING RISK (1-YES, 0-NO)
    	DE--INDICATOR OF SECOND COMPETING RISK
    DATAOUT--NAME OF OUTPUT DATA SET CONTAINING
    	CIR--CUMULATIVE INCIDENCE FUNCTION FOR 1ST COMPETING RISK
    	CID--CUMULATIVE INCIDENCE FUNCTION FOR 2ST COMPETING RISK

*/

data work;  set &datain;
t=&x;
r=&re;
d=&de;
zero=0;

/* COMPUTE CRUDE CUMUALTIVE HAZARD FOR FIRST COMPETING RISK */
proc phreg data=work noprint; 
model t*r(0)=zero;
output out=rel  logsurv=chr  /method=emp;
 
 /* COMPUTE CRUDE CUMUALTIVE HAZARD FOR SECOND COMPETING RISK */
proc phreg data=work noprint; 
model t*d(0)=zero;
output out=dead  logsurv=chd  /method=emp;
 
 
 /* COMPUTE cumualtive incidence */
data both;  merge rel dead;  by t;
retain s 1
retain cr 0;
retain cd 0;
retain cumincr 0;
retain cumincd 0;
hr=-(cr+chr);
hd=-(cd+chd);

/* NOTE HR AND HD ARE THE JUMPS IN THE CUMUALTIVE CRUDE HAZARDS AT THIS TIME */

cr=-chr;
cd=-chd;
cir=cumincr+hr*s;
cumincr=cir;
cid=cumincd+hd*s;
cumincd=cid;
s=s*(1-hr-hd);
/* NOTE S IS KAPLAN-MEIER ESTIMATE IGNORING CAUSE OF FAILURE */
data &dataout;  set both;
&x=t;
&cir=cir;  &cid=cid;
keep &x &cir &cid;
run;
%mend;
```

And now the `pseudoci`macro:

```{sas}
#| label: macro-pseudoci-sas
#| eval: false 
#| output: false
%macro pseudoci(datain,x,r,d,howmany,datatau,dataout);

/*    MACRO COMPUTES PSEUDOVALUES BASED ON THE CUMUALTIVE INCIDENCE FUNCTION
      FOR BOTH OF TWO COMPETING RISKS  
      TIME
      INPUTS:
      DATAIN---INPUT DATA SET
      X--TIME VARIABLE
      R--INDICATOR OF FIRST COMPETING RISK (1-YES, 0-NO)
      D--INDICATOR OF SECOND COMPETING RISK
      HOWMANY---SAMPLE SIZE
     
      DATATAU---SUBSET OF INPUT DATA SET AT WHICH PSEUDO VALUES ARE COMPUTED 
                DATA SET HAS SINGLE VARIABLE "TIME"
                
      DATAOUT---OUTPUT DATA SET WHICH CONATINS PSUK,K=1,...,HOWMANY THE PSEUDO
                VALUES AT EACH TIME POINT (Note output data set
                 includes orginal data sorted by time)
      
*/

proc sort data=&datain;  by &x;

data keep;  set &datatau;
find=1;

proc sort data=keep;  by time;

data point;  set &datain;
time=&x;
keep=1;
data point;  merge point keep;  by time;
keep time find keep;
 
data useme;  set point;
retain temp -1;
if keep = 1 then temp=time;
tuse=temp; 
if find ne 1 then delete;
&x=tuse;
proc print;

/* PREPARE DATA SET WITH MISSING VALUES FOR DEADK AND RELAPSEK TO BE USED IN COMPUTING
   ESTIMATED CUMULATIVE INCIDENCE WITH KTH OBSERVATION DELETED*/
proc sort data=&datain;
by &x;
data newdat;  set &datain ;
id+1;
array iobsd(&howmany) dead1-dead&howmany;
array iobsr(&howmany) relapse1-relapse&howmany;
do j=1 to &howmany;
iobsd(j)=&d;
iobsr(j)=&r;
if j=id then do; iobsr(j)=.; iobsd(j)=.; end;
end;

data out;  set newdat;
drop dead1-dead&howmany relapse1-relapse&howmany;
/* COMPUTE CI FOR 1ST (CIRALL) AND 2ND (CIDALL) FOR FULL SAMPLE, STORE IN SALL*/
%cuminc(newdat,&x,&r,&d,sall,cirall,cidall);

%do ip=1 %to &howmany;

/* COMPUTE CI FOR 1ST (CIRALL) AND 2ND (CIDALL) FOR REDUCED SAMPLE, STORE IN SIP*/
%cuminc(newdat,&x,relapse&ip,dead&ip,stemp,cir1,cid1);

/* COMPUTE PSEUDOVALUES FOR BOTH RISK AT EVERY DATA POINT AND ADD TO FILE */ 
data ps; merge sall stemp;  by &x;
retain cirtemp 0;
retain cidtemp 0;
if cir1=. then cir1=cirtemp;
cirtemp=cir1;
rpsu&ip=&howmany*cirall- (&howmany-1)*cir1;
 if cid1=. then cid1=cidtemp;
cidtemp=cid1;
dpsu&ip=&howmany*cidall- (&howmany-1)*cid1;

data out; merge out ps useme; by &x;
if find ne 1 then delete;
keep time rpsu1-rpsu&ip dpsu1-dpsu&ip &x;
run;
%end;
 
 data &dataout;  set newdat; 
 drop dead1-dead&howmany relapse1-relapse&howmany;
 
 data all;  set out;
  
 array yr(&howmany) rpsu1-rpsu&howmany;
array yd(&howmany) dpsu1-dpsu&howmany;
do j=1 to &howmany;
rpseudo=yr(j);
dpseudo=yd(j);
id=j;
output;
end;
keep id time rpseudo dpseudo;
 proc sort data=all;  by id;
 data &dataout; merge &dataout all;
 by id;
 retain otime -1;
 retain oid -1;
 if id eq oid and otime=time then delete;
 else do; oid=id; otime=time; end;
 run;
 %mend;
```

#### Table

```{sas}
#| label: table-6.4-sas
#| eval: false 
#| output: false
* NB: Inside the macros below a variable called `id` is created which will interfere 
  with your identification variable is called `id` in your data set,
  in which case you will need to rename your `id` variable; 

* create indicator variables for each competing risk as required by the macro;
proc import out=pbc3
	datafile="data/pbc3.csv"
	dbms=csv replace;
run;
data pbc3; 
	set pbc3;
	log2bili=log2(bili);
	years=days/365.25;
	trans=status=1;
	death=status=2;
	rename id=ptno;
run;

data timepoint;
	input time;
	datalines;
	2
	;
run;

%pseudoci(pbc3,years,trans,death,349,timepoint,cumincpv1);

* rpseudo: transplant; 
* dpseudo: death;

* logit link function;
proc genmod data=cumincpv1;
	class ptno;
	model dpseudo = tment / dist=normal noscale link=logit; 
	repeated subject=ptno / corr=ind;
run;
proc genmod data=cumincpv1;
	class ptno;
	model dpseudo = tment alb log2bili / dist=normal noscale link=logit; 
	repeated subject=ptno / corr=ind;
run;

* cloglog link function;
proc genmod data=cumincpv1;
	class ptno;
	fwdlink link = log(-log(1-_mean_));
	invlink ilink = 1 - exp(-exp(_xbeta_));
	model dpseudo = tment / dist=normal noscale ; 
	repeated subject=ptno / corr=ind;
run;
proc genmod data=cumincpv1;
	class ptno;
	fwdlink link = log(-log(1-_mean_));
	invlink ilink = 1 - exp(-exp(_xbeta_));
	model dpseudo = tment alb log2bili / dist=normal noscale ; 
	repeated subject=ptno / corr=ind;
run;
```
:::

### In-text, p. 233: cloglog link function - year 1,2,3

::: {.panel-tabset}

## R

```{r}
#| label: in-text-r
#calculate the pseudo-observations
pseudo <- pseudoci(time=pbc3$days/365.25,event=pbc3$status,tmax=c(1,2,3))
#rearrange the data into a long data set, use only pseudo-observations for death,
# i.e.,  status=2:  pseudo$pseudo[[2]],
b <- NULL
for(it in 1:length(pseudo$time)){
b <- rbind(b,cbind(pbc3,death.pseudo = pseudo$pseudo[[2]][,it],
tpseudo = pseudo$time[it],idno=1:nrow(pbc3)))
}
dataci3 <- b[order(b$idno),]

# geese
summgeese(geese(death.pseudo ~ tment + alb + log2bili + factor(tpseudo),
                data = subset(dataci3,!is.na(alb)), id=idno,
                family=gaussian, mean.link = "cloglog", corstr="independence"))

# svyglm
svydata3 <- svydesign(~idno, variables= ~., data=dataci3, weight= ~1)
summsvy(svyglm(death.pseudo ~ tment + alb + log2bili+factor(tpseudo)-1,
               design=svydata3, family= gaussian(link= bcloglog())))
```

## SAS

```{sas}
#| label: in-text-sas
#| eval: false 
#| output: false

data timepoints;
	input time;
	datalines;
	1
	2
	3
	;
run;
%pseudoci(pbc3,years,trans,death,349,timepoints,cumincpv3);

* cloglog link function - year 1,2,3;
proc genmod data=cumincpv3;
	class ptno time;
	fwdlink link = log(-log(1-_mean_));
	invlink ilink = 1 - exp(-exp(_xbeta_));
	model dpseudo = tment alb log2bili time / dist=normal noscale ; 
	repeated subject=ptno / corr=ind;
run;
```

:::

### Table 6.5

::: {.panel-tabset}

## R

#### 3 time points

```{r}
#| label: table-6.5-3times-r

# Calculate pseudo-values based on Aalen-Johansen estimates using pseudoci()
# and merge with pbc3 data
pseudo <- pseudoci(time=pbc3$days/365.25,event=pbc3$status,tmax=1:3)
# rearrange the data into a long data set, use only pseudo-observations for death,
# i.e.,  status=2:  pseudo$pseudo[[2]],
b <- NULL
for(it in 1:length(pseudo$time)){
b <- rbind(b,cbind(pbc3,death.pseudo = pseudo$pseudo[[2]][,it],
                   tpseudo = pseudo$time[it],idno=1:nrow(pbc3)))
}
dataci3 <- b[order(b$idno),]

# geese
summgeese(geese(death.pseudo~tment+alb+log2bili+sex+age+factor(tpseudo),
                data = subset(dataci3,!is.na(alb)),id=idno,
                family=gaussian, mean.link = "cloglog", corstr="independence"))

# svyglm
svydata3 <- svydesign(~idno, variables= ~., data=dataci3, weight= ~1)
summsvy(svyglm(death.pseudo ~ tment+alb+log2bili+sex+age+factor(tpseudo)-1,
               design=svydata3, family= gaussian(link= bcloglog())))
```

#### 10 time points

```{r}
#| label: table-6.5-10times-r

# Calculate pseudo-values based on Aalen-Johansen estimates using pseudoci()
# and merge with pbc3 data
pseudo <- pseudoci(time=pbc3$days/365.25,event=pbc3$status,tmax=seq(0.5,5,0.5))
# rearrange the data into a long data set, use only pseudo-observations for death,
# i.e.,  status=2:  pseudo$pseudo[[2]],
b <- NULL
for(it in 1:length(pseudo$time)){
b <- rbind(b,cbind(pbc3,death.pseudo = pseudo$pseudo[[2]][,it],
tpseudo = pseudo$time[it],idno=1:nrow(pbc3)))
}
dataci10 <- b[order(b$idno),]

# geese
summgeese(geese(death.pseudo~tment+alb+log2bili+sex+age+factor(tpseudo),
                data = subset(dataci10,!is.na(alb)),id=idno,
                family=gaussian, mean.link = "cloglog", corstr="independence"))

# svyglm
svydata10 <- svydesign(~idno, variables= ~., data=dataci10, weight= ~1)
summsvy(svyglm(death.pseudo ~ tment+alb+log2bili+sex+age+factor(tpseudo)-1,
               design=svydata10, family= gaussian(link=bcloglog())))
```

## SAS

#### 3 time points

```{sas}
#| label: table-6.5-3times-sas
#| eval: false 
#| output: false

* cloglog link function - 3 time points;
proc genmod data=cumincpv3;
	class ptno time;
	fwdlink link = log(-log(1-_mean_));
	invlink ilink = 1 - exp(-exp(_xbeta_));
	model dpseudo = tment alb log2bili sex age time / dist=normal noscale ; 
	repeated subject=ptno / corr=ind;
run;

               Analysis Of GEE Parameter Estimates
                Empirical Standard Error Estimates

                      Standard   95% Confidence
 Parameter   Estimate    Error       Limits            Z Pr > |Z|

 Intercept    -6.4063   2.2176 -10.7526  -2.0599   -2.89   0.0039
 tment        -0.2717   0.3364  -0.9311   0.3877   -0.81   0.4194
 alb          -0.0760   0.0331  -0.1408  -0.0112   -2.30   0.0216
 log2bili      0.6657   0.1205   0.4295   0.9019    5.52   <.0001
 sex           0.5017   0.3990  -0.2803   1.2838    1.26   0.2086
 age           0.0734   0.0223   0.0298   0.1170    3.30   0.0010
 time      1  -1.2504   0.2779  -1.7951  -0.7056   -4.50   <.0001
 time      2  -0.5596   0.1729  -0.8985  -0.2207   -3.24   0.0012
 time      3   0.0000   0.0000   0.0000   0.0000     .      .

```


#### 10 time points

Initial values from R used to make `proc genmod` converge.



```{sas}
#| label: table-6.5-10times-sas
#| eval: false 
#| output: false

* cloglog link function - 10 time points;
data time10points;
	input time;
	datalines;
	.5
	1
	1.5
	2
	2.5
	3
	3.5
	4
	4.5
	5
	;
run;
%pseudoci(pbc3,years,trans,death,349,time10points,cumincpv10);

proc genmod data=cumincpv10;
	class ptno time(ref="5");
	fwdlink link = log(-log(1-_mean_));
	invlink ilink = 1 - exp(-exp(_xbeta_));
	model dpseudo = tment alb log2bili sex age time / dist=normal noscale 
  intercept=-8.3
  initial=
-0.4
-0.04
 0.6
 0.8
 0.09
-3.8
-2.0
-1.5
-1.3
-1.1
-0.7
-0.4
-0.2
-0.2
;
	repeated subject=ptno / corr=ind;
run;
 
                Analysis Of GEE Parameter Estimates
                 Empirical Standard Error Estimates

                        Standard   95% Confidence
 Parameter     Estimate    Error       Limits            Z Pr > |Z|

 Intercept      -8.3178   2.2810 -12.7885  -3.8472   -3.65   0.0003
 tment          -0.4079   0.3175  -1.0301   0.2143   -1.28   0.1988
 alb            -0.0378   0.0322  -0.1009   0.0253   -1.17   0.2403
 log2bili        0.6686   0.1181   0.4370   0.9001    5.66   <.0001
 sex             0.8515   0.3880   0.0910   1.6120    2.19   0.0282
 age             0.0963   0.0221   0.0530   0.1396    4.36   <.0001
 time      0.5  -3.8381   0.8557  -5.5151  -2.1610   -4.49   <.0001
 time      1    -2.0609   0.3797  -2.8050  -1.3167   -5.43   <.0001
 time      1.5  -1.5982   0.3150  -2.2157  -0.9808   -5.07   <.0001
 time      2    -1.3716   0.2895  -1.9391  -0.8041   -4.74   <.0001
 time      2.5  -1.1589   0.2688  -1.6858  -0.6321   -4.31   <.0001
 time      3    -0.7065   0.2216  -1.1408  -0.2722   -3.19   0.0014
 time      3.5  -0.4978   0.2005  -0.8908  -0.1048   -2.48   0.0130
 time      4    -0.2019   0.1463  -0.4886   0.0848   -1.38   0.1674
 time      4.5  -0.2051   0.1471  -0.4933   0.0831   -1.39   0.1631
 time      5     0.0000   0.0000   0.0000   0.0000     .      .
```

:::


### Table 6.6

::: {.panel-tabset}
## R
```{r}
#| label: table-6.6-r

# Lost years
pseudolost <- pseudoyl(time = pbc3$days / 365.25,
                       event = as.integer(pbc3$status),
                       tmax = 3)
trans <- cbind(pbc3,pseudo = pseudolost$pseudo[[1]],idno=1:nrow(pbc3))
death <- cbind(pbc3,pseudo = pseudolost$pseudo[[2]],idno=1:nrow(pbc3))
svytrans <- svydesign(~idno, variables= ~., data=trans, weight= ~1)
svydeath <- svydesign(~idno, variables= ~., data=death, weight= ~1)

# Transplantation
summgeese(geese(pseudo ~ tment,data = trans,id = idno,
                family = gaussian, corstr = "independence"))
summsvy(svyglm(pseudo ~ tment, design=svytrans, family=gaussian))

summgeese(geese(pseudo ~ tment + alb + log2(bili),
                data = subset(trans,!is.na(alb)), id = idno,
                family = gaussian, corstr = "independence"))
summsvy(svyglm(pseudo ~ tment+alb+log2bili,design=svytrans,family= gaussian))

# Death without transplantation
summgeese(geese(pseudo ~ tment, data = death, id = idno,
                family = gaussian, corstr = "independence"))
summsvy(svyglm(pseudo ~ tment, design=svydeath, family=gaussian))


summgeese(geese(pseudo ~ tment + alb + log2(bili),
                data = subset(death,!is.na(alb)), id = idno, 
                family = gaussian, corstr = "independence"))
summsvy(svyglm(pseudo ~ tment+alb+log2bili,design=svydeath,family= gaussian))
```


## SAS-NA

:::

### Figure 6.12

::: {.panel-tabset}
## R

#### left

```{r}
#| label: figure-6.12left-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%
 
# comp. end point t=2 smlg med IJ
library(pseudo)
library(survival)
pbc3$nystatus<-ifelse(pbc3$status > 0, 1, 0)

pseudo <- pseudosurv(time = pbc3$days,
                     event = pbc3$nystatus,
                     tmax=2 * 365.25)
fit <- survfit(Surv(days, status > 0) ~ 1, data = pbc3)

IJpseudo <- pseudo(fit, times = 2 * 365.25, addNA = TRUE, data.frame = TRUE, minus1 = TRUE)

pdata <- data.frame(IJpseudo = IJpseudo$pseudo,
                    pseudo = pseudo$pseudo,
                    diff = IJpseudo$pseudo - pseudo$pseudo)

fig6.11left <- ggplot(aes(x = pseudo, y = IJpseudo), data = pdata) +
  geom_point(size = 4, shape = 1) +
  geom_line(size = 1) +
  ylab("IJ pseudo-value") +
  xlab("Pseudo-value") +
  scale_x_continuous(limits = c(-0.2, 1),
                     breaks = seq(-0.2, 1, by = 0.2)) +
  scale_y_continuous(limits = c(-0.2, 1),
                     breaks = seq(-0.2, 1, by = 0.2)) +
  theme_general

fig6.11left
```

#### right

```{r}
#| label: figure-6.12right-r
#| fig-width: 8.27
#| fig-height: 8.27
#| out-width: 66%

fig6.11right <- ggplot(aes(x = pseudo, y = IJpseudo - pseudo), data = pdata) +
  geom_point(size = 4, shape = 1) +
  ylab("Difference") +
  xlab("Pseudo-value") +
  scale_x_continuous(limits = c(-0.2, 1),
                     breaks = seq(-0.2, 1, by = 0.2)) +
  scale_y_continuous(limits = c(-0.01, 0.01),
                     breaks = seq(-0.01, 0.01, by = 0.005)) +
  theme_general

fig6.11right
```


## SAS-NA
```{sas}
#| label: figure-6.12-sas
#| eval: false 
#| output: false
```

:::

